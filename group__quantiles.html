<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sgsPy: quantiles</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sgsPy
   </div>
   <div id="projectbrief">structurally guided sampling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__quantiles.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">quantiles <div class="ingroups"><a class="el" href="group__dev.html">Developer Documentation</a> &raquo; <a class="el" href="group__stratify.html">stratify</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9cda3c44cefad181b3786ed5bcac27b7" id="r_ga9cda3c44cefad181b3786ed5bcac27b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9cda3c44cefad181b3786ed5bcac27b7">sgs::quantiles::calcSPQuantiles</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;band, std::vector&lt; double &gt; &amp;probabilities, std::vector&lt; double &gt; &amp;<a class="el" href="#ga684687f586780d41b0b2723e951230e9">quantiles</a>)</td></tr>
<tr class="memitem:ga4807be4deceffcc0b613818f1ee8f698" id="r_ga4807be4deceffcc0b613818f1ee8f698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4807be4deceffcc0b613818f1ee8f698">sgs::quantiles::calcDPQuantiles</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;band, std::vector&lt; double &gt; &amp;probabilities, std::vector&lt; double &gt; &amp;<a class="el" href="#ga684687f586780d41b0b2723e951230e9">quantiles</a>)</td></tr>
<tr class="memitem:ga8c03e74553ad5fde985a243dae5a39a7" id="r_ga8c03e74553ad5fde985a243dae5a39a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga8c03e74553ad5fde985a243dae5a39a7">sgs::quantiles::batchCalcSPQuantiles</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;band, std::vector&lt; double &gt; &amp;probabilities, std::vector&lt; double &gt; &amp;<a class="el" href="#ga684687f586780d41b0b2723e951230e9">quantiles</a>, std::mutex &amp;mutex, std::condition_variable &amp;cv, bool &amp;calculated, double eps)</td></tr>
<tr class="memitem:ga5ac57f4334d44e69f37b99c2e266a041" id="r_ga5ac57f4334d44e69f37b99c2e266a041"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5ac57f4334d44e69f37b99c2e266a041">sgs::quantiles::batchCalcDPQuantiles</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;band, std::vector&lt; double &gt; &amp;probabilities, std::vector&lt; double &gt; &amp;<a class="el" href="#ga684687f586780d41b0b2723e951230e9">quantiles</a>, std::mutex &amp;mutex, std::condition_variable &amp;cv, bool &amp;calculated, double eps)</td></tr>
<tr class="memitem:gad3a8bd7c956876dc686da473af551613" id="r_gad3a8bd7c956876dc686da473af551613"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gad3a8bd7c956876dc686da473af551613">sgs::quantiles::processMapPixel</a> (size_t index, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;dataBand, void *p_dataBuffer, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;stratBand, void *p_stratBuffer, std::vector&lt; double &gt; &amp;<a class="el" href="#ga684687f586780d41b0b2723e951230e9">quantiles</a>, size_t multiplier, bool &amp;mapNan, size_t &amp;mapStrat)</td></tr>
<tr class="memitem:gae07edcfd864a2acbb0326c4bec8bcde6" id="r_gae07edcfd864a2acbb0326c4bec8bcde6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae07edcfd864a2acbb0326c4bec8bcde6">sgs::quantiles::processPixel</a> (size_t index, void *p_data, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> *p_dataBand, void *p_strat, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> *p_stratBand, std::vector&lt; double &gt; &amp;<a class="el" href="#ga684687f586780d41b0b2723e951230e9">quantiles</a>)</td></tr>
<tr class="memitem:ga684687f586780d41b0b2723e951230e9" id="r_ga684687f586780d41b0b2723e951230e9"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *, std::unordered_map&lt; std::string, std::vector&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga684687f586780d41b0b2723e951230e9">sgs::quantiles::quantiles</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, std::map&lt; int, std::vector&lt; double &gt; &gt; userProbabilites, bool map, std::string filename, std::string tempFolder, bool largeRaster, int threadCount, std::map&lt; std::string, std::string &gt; driverOptions, double eps)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga5ac57f4334d44e69f37b99c2e266a041" name="ga5ac57f4334d44e69f37b99c2e266a041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ac57f4334d44e69f37b99c2e266a041">&#9670;&#160;</a></span>batchCalcDPQuantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::quantiles::batchCalcDPQuantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>band</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probabilities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;</td>          <td class="paramname"><span class="paramname"><em>mutex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable &amp;</td>          <td class="paramname"><span class="paramname"><em>cv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>calculated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helper function is used to calculate the quantiles of a large raster which is more efficient to calculate in batches rather than trying to allocate into memory. This is the double precision version of this function.</p>
<p>Intel's MKL (Math Kernel Library) package is used to calculate the quantiles. The MKL package does not account for nan values, so the data must be filtered first, leaving only the data pixel values left.</p>
<p>the following MKL VSL (Vector Statistics Library) functions are used to calculate the quantiles: vsldSSCreateTask() vsldSSEditStreamQuantiles() vsldSSCompute() vslSSDeleteTask()</p>
<p>CreateTask is called at the start of execution, and VSLsSSEditStreamQuantiles() is called after the first set of values has been written into the buffer. It was found that calling this function before resulted in incorrect values, although the funciton still only has to be called once. The Compute function is called many times, to continuously update the quantiles across batches. The fast calculation method is used, which means afterwards the Compute funciton must be called again with the normal method and an observable count of 0 to get the final quantile values. Quantile streaming algorithms are not exact, since the entire raster must be in memory to get the most precise possible values. However, the amount of error can be controlled to a specific epsilon (eps) value.</p>
<p>The Quantile streaming method is the method introduced by Zhang et al. and utilized by MKL: <a href="https://web.cs.ucla.edu/~weiwang/paper/SSDBM07_2.pdf">https://web.cs.ucla.edu/~weiwang/paper/SSDBM07_2.pdf</a> <a href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-summary-statistics-notes/2021-1/computing-quantiles-with-vsl-ss-method-squants-zw.html">https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-summary-statistics-notes/2021-1/computing-quantiles-with-vsl-ss-method-squants-zw.html</a></p>
<p>Due to the fact that large raster processing in batches is multi-threaded in SGS, a condition variable (cv) is used to ensure a thread which would be using the calculated quantiles doesn't begin processing or writing any data before the quantiles are finalized. The shared resource is a boolean representing the band which is set to true by this thread once the quantiles are calculated. Any number of processing threads may be waiting on the quantiles of this band to be calculated, so notify_all is called on the cv to wake those threads up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>band </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>probabilities </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>quantiles </td></tr>
    <tr><td class="paramname">std::mutex&amp;</td><td>mutex </td></tr>
    <tr><td class="paramname">std::condition_variable&amp;</td><td>cdv </td></tr>
    <tr><td class="paramname">bool&amp;</td><td>calculated </td></tr>
    <tr><td class="paramname">double</td><td>eps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8c03e74553ad5fde985a243dae5a39a7" name="ga8c03e74553ad5fde985a243dae5a39a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c03e74553ad5fde985a243dae5a39a7">&#9670;&#160;</a></span>batchCalcSPQuantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::quantiles::batchCalcSPQuantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>band</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probabilities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::mutex &amp;</td>          <td class="paramname"><span class="paramname"><em>mutex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::condition_variable &amp;</td>          <td class="paramname"><span class="paramname"><em>cv</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>calculated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helper function is used to calculate the quantiles of a large raster which is more efficient to calculate in batches rather than trying to allocate into memory. This is the single precision version of this function, which is used for all raster data types except double precision floating point values.</p>
<p>Both the quantile probabilities, and the quantiles themselves are double precision, however, so they must be converted before and after execution to and from single precision floating point.</p>
<p>Intel's MKL (Math Kernel Library) package is used to calculate the quantiles. The MKL package does not account for nan values, so the data must be filtered first, leaving only the data pixel values left.</p>
<p>the following MKL VSL (Vector Statistics Library) functions are used to calculate the quantiles: vslsSSCreateTask() vslsSSEditStreamQuantiles() vslsSSCompute() vslSSDeleteTask()</p>
<p>CreateTask is called at the start of execution, and VSLsSSEditStreamQuantiles() is called after the first set of values has been written into the buffer. It was found that calling this function before resulted in incorrect values, although the funciton still only has to be called once. The Compute function is called many times, to continuously update the quantiles across batches. The fast calculation method is used, which means afterwards the Compute funciton must be called again with the normal method and an observable count of 0 to get the final quantile values. Quantile streaming algorithms are not exact, since the entire raster must be in memory to get the most precise possible values. However, the amount of error can be controlled to a specific epsilon (eps) value.</p>
<p>The Quantile streaming method is the method introduced by Zhang et al. and utilized by MKL: <a href="https://web.cs.ucla.edu/~weiwang/paper/SSDBM07_2.pdf">https://web.cs.ucla.edu/~weiwang/paper/SSDBM07_2.pdf</a> <a href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-summary-statistics-notes/2021-1/computing-quantiles-with-vsl-ss-method-squants-zw.html">https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-summary-statistics-notes/2021-1/computing-quantiles-with-vsl-ss-method-squants-zw.html</a></p>
<p>Due to the fact that large raster processing in batches is multi-threaded in SGS, a condition variable (cv) is used to ensure a thread which would be using the calculated quantiles doesn't begin processing or writing any data before the quantiles are finalized. The shared resource is a boolean representing the band which is set to true by this thread once the quantiles are calculated. Any number of processing threads may be waiting on the quantiles of this band to be calculated, so notify_all is called on the cv to wake those threads up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>band </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>probabilities </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>quantiles </td></tr>
    <tr><td class="paramname">std::mutex&amp;</td><td>mutex </td></tr>
    <tr><td class="paramname">std::condition_variable&amp;</td><td>cdv </td></tr>
    <tr><td class="paramname">bool&amp;</td><td>calculated </td></tr>
    <tr><td class="paramname">double</td><td>eps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4807be4deceffcc0b613818f1ee8f698" name="ga4807be4deceffcc0b613818f1ee8f698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4807be4deceffcc0b613818f1ee8f698">&#9670;&#160;</a></span>calcDPQuantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::quantiles::calcDPQuantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>band</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probabilities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helper function is used to calculate the quantiles of a raster which is entirely in memory. This is the double precision version of this function.</p>
<p>Intel's MKL (Math Kernel Library) package is used to calculate the quantiles. The MKL package does not account for nan values, so the data must be filtered first, leaving only the data pixel values left.</p>
<p>the following MKL VSL (Vector Statistics Library) functions are used to calculate the quantiles: vsldSSCreateTask() vsldSSEditQuantiles() vsldSSCompute() vslSSDeleteTask()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>band </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>probabilities </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>quantiles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9cda3c44cefad181b3786ed5bcac27b7" name="ga9cda3c44cefad181b3786ed5bcac27b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9cda3c44cefad181b3786ed5bcac27b7">&#9670;&#160;</a></span>calcSPQuantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::quantiles::calcSPQuantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>band</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>probabilities</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This helper function is used to calculate the quantiles of a raster which is entirely in memory. This is the single precision version of this function, which is used for all raster data types except double precision floating point values.</p>
<p>Both the quantile probabilities, and the quantiles themselves are double precision, however, so they must be converted before and after execution to and from single precision floating point.</p>
<p>Intel's MKL (Math Kernel Library) package is used to calculate the quantiles. The MKL package does not account for nan values, so the data must be filtered first, leaving only the data pixel values left.</p>
<p>the following MKL VSL (Vector Statistics Library) functions are used to calculate the quantiles: vslsSSCreateTask() vslsSSEditQuantiles() vslsSSCompute() vslSSDeleteTask()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>band </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>probabilities </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>quantiles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad3a8bd7c956876dc686da473af551613" name="gad3a8bd7c956876dc686da473af551613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3a8bd7c956876dc686da473af551613">&#9670;&#160;</a></span>processMapPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::quantiles::processMapPixel </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dataBand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p_dataBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stratBand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p_stratBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>mapNan</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>mapStrat</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper function for processing a pixel of data when a mapped stratification is being created.</p>
<p>First, the value is read in as a double, and it is determined whether the pixel is a nan pixel or not. The mapNan boolean is updated in addition to the isNan boolean, to ensure that if one band within the raster is nan at a certain pixel then the mapped raster (but not necessarily all output rasters) is also nan at that pixel.</p>
<p>Then, if it isn't a nan pixel the lower bound of the value within the vector of break values is found. For example, if the value was 3 and the breaks vector was [2, 4, 6], the lower bound would be 1, which is the index of 4, the first value larger than 3 in the breaks vector. This lower bound is the strata. This strata (or the nan value) is then written with the appropriate type to the strat raster band.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_t</td><td>index </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>dataBand </td></tr>
    <tr><td class="paramname">void</td><td>*p_dataBuffer </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>stratBand </td></tr>
    <tr><td class="paramname">void</td><td>*p_stratBuffer </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>quantiles </td></tr>
    <tr><td class="paramname">size_t</td><td>multiplier </td></tr>
    <tr><td class="paramname">bool&amp;</td><td>mapNan </td></tr>
    <tr><td class="paramname">size_t</td><td>&amp;mapStrat </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae07edcfd864a2acbb0326c4bec8bcde6" name="gae07edcfd864a2acbb0326c4bec8bcde6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae07edcfd864a2acbb0326c4bec8bcde6">&#9670;&#160;</a></span>processPixel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::quantiles::processPixel </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p_data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> *</td>          <td class="paramname"><span class="paramname"><em>p_dataBand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>p_strat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> *</td>          <td class="paramname"><span class="paramname"><em>p_stratBand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a helper function for processing a pixel of data.</p>
<p>First, the value is read in as a double, and it is determined whether the pixel is a nan pixel or not.</p>
<p>Then, if it isn't a nan pixel the lower bound of the value within the vector of break values is found. For example, if the value was 3 and the breaks vector was [2, 4, 6], the lower bound would be 1, which is the index of 4, the first value larger than 3 in the breaks vector. This lower bound is the strata. This strata (or the nan value) is then written with the appropriate type to the strat raster band.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size_t</td><td>index </td></tr>
    <tr><td class="paramname">void</td><td>*p_data </td></tr>
    <tr><td class="paramname">RasterBandMetaData</td><td>*p_dataBand </td></tr>
    <tr><td class="paramname">void</td><td>*p_strat </td></tr>
    <tr><td class="paramname">RasterBandMetaData</td><td>*p_stratBand </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>quantiles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga684687f586780d41b0b2723e951230e9" name="ga684687f586780d41b0b2723e951230e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga684687f586780d41b0b2723e951230e9">&#9670;&#160;</a></span>quantiles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *, std::unordered_map&lt; std::string, std::vector&lt; double &gt; &gt; &gt; sgs::quantiles::quantiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; int, std::vector&lt; double &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>userProbabilites</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>tempFolder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>largeRaster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>threadCount</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, std::string &gt;</td>          <td class="paramname"><span class="paramname"><em>driverOptions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>eps</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function stratifies a given raster using user-defined probabilities. The probabilities (quantiles) are provided as a vector of doubles mapped to a band index.</p>
<p>The function can be run on a single raster band or multiple raster bands, and the user may pass the map variable to combine the stratification of the given raster bands.</p>
<p>The function can be thought of in four different sections: the setup, the quantiles calculation, the processing, and the finish/return. During the setup, metadata is acquired for the input raster, and an output dataset is created which depends on user-given parameters and the input raster. During the quantiles calculation, Intel's Math Kernel Library (MKL) is used to calculate quantiles either with the entire raster in memory or in batches. During the processing step the raster is iterated through, either by blocks or with the entire raster in memory, the strata are determined for each pixel and then written to the output dataset. During the finish/return step, a GDALRasterWrapper object is created using the output dataset.</p>
<p>SETUP: the data structures holding metadata are initialized and it is determined whether the raster is a virtual raster or not, and if it is a virtual raster whether it is fully in-memory or whether it must be stored on disk.</p>
<p>If the user provides an output filename, the dataset will not be a virtual dataset instead it will be associated with the filename. If the user does not provide an output filename then a virtual dataset driver will be used. In the case of a large raster (whether or not the raster is large enough for this is calculated and passed by hte Python side of the application), the dataset will be VRT. If the package is comfortable fitting the entire raster in memory, an in-memory dataset will be used.</p>
<p>The input raster bands are iterated through, metadata is stored on them, and bands are created for the output dataset. In the case of a VRT dataset, each band is a complete dataset itself which must be added after it has been written to. In the case of a MEM dataset, the bands must be acquired from the input raster. Both MEM and VRT support the addBand function, and support bands of different types. Thus, the bands are added dynamically while iterating through input raster bands. Non virtual formats require the data types to be known at dataset initialization and don't support the addBand function, so the dataset must be created after iterating through the input bands.</p>
<p>QUANTILES CALCULATION: There are four different functions which do the quantiles calculation. Different functions are used depending on whether the raster should be batch processed, or whether it is entirely in memory. Further, there are different functions for single precision (float) or double precision (double) floating point values. Intels Math Kernel Library (MKL) is used to calculate the quantiles.</p>
<p>For single precision vs. double precision, the only case where double precision would be used is if the raster data type is double. the functions within the MKL library are slightly different for double and single precision. Further, the input and output vectors representing quantile probabilities and the quantiles themselves are vectors of double, so in the case where single precision is used, intermediate versions of the data must be written to and read from at the beginning and end of the function. The reasing why double precision is not used in every case, is because the same amount of values of single precision take up half the ammount of memory as their double precision counterparts. As a result, the memory usage due to intermediate stored values should be significantly less for single precision floating point values.</p>
<p>For batch processing vs non-batch processing, slightly different algorithms are used. The batch processing algorithm is a quantile streaming algorithm within MKL which creates a fast and accurate approximation of the quantiles without requiring the whole raster to be in memory at once. More information is contained in the documentation for those particular functions.</p>
<p>Information on the quantile streaming algorithm can be found here:</p><ul>
<li><a href="https://www.cs.unc.edu/~weiwang/paper/SSDBM07_2.pdf">https://www.cs.unc.edu/~weiwang/paper/SSDBM07_2.pdf</a></li>
<li><a href="https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-summary-statistics-notes/2021-1/computing-quantiles-with-vsl-ss-method-squants-zw.html">https://www.intel.com/content/www/us/en/docs/onemkl/developer-reference-summary-statistics-notes/2021-1/computing-quantiles-with-vsl-ss-method-squants-zw.html</a></li>
</ul>
<p>PROCESSING: the processing section iterated through ever pixel in every input band, and calculates/writes the strata to the corresponding output band.</p>
<p>There are four different cases dealing with whether or not the entire raster band is allocated in memory (the largeRaster bariable is false), and whether or not the values of each band should be mapped to an extra output raster band.</p>
<p>If the raster is large, it is porcessed in blocks and split into groups of blocks to be processed by multiple threads. If the raster bands are in-memory, the entire raster is processed at once by a single thread. The mapped rasters store information on an extra output raster band, the output values of which are determined as a function of all other output raster bands. The multipliers vector stores the information for this.</p>
<p>For the large rasters, the processing starts out by splitting the raster into chunks depending on the number of threads. A thread is then ctreated for each chunk. Within each thread, the blocks within it's designated chunk are iterated through and first read from the input bands, processed, then written to the output bands. In the case of a mapped raster all of the bands are iterated through alongside achother so that the intermediate mapping calculations don't have to be written then read again. In the case of a non mapped raster, each band is processed sequentially.</p>
<p>CLEANUP: If the output dataset is a VRT dataset, the dataset which represent its bands (which have not yet been added as bands) must be added as bands now that they are populated with data and are thus allowed to be added.</p>
<p>If the dataset output bands are fully in memory, they are moved to a vector from their metadata objects to be passed as a parameter to the GDALRasterWrapper constructor (or not if the bands aren't in memory). This GDALRasterWrapper is then returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">std::map&lt;int,std::vector&lt;double&gt;&gt;</td><td>userProbabilities </td></tr>
    <tr><td class="paramname">bool</td><td>map </td></tr>
    <tr><td class="paramname">std::string</td><td>filename </td></tr>
    <tr><td class="paramname">std::string</td><td>tempFolder, </td></tr>
    <tr><td class="paramname">bool</td><td>largeRaster, </td></tr>
    <tr><td class="paramname">int</td><td>threadCount </td></tr>
    <tr><td class="paramname">std::map&lt;std::string,std::string&gt;</td><td>driverOptions, </td></tr>
    <tr><td class="paramname">double</td><td>eps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>GDALRasterWrapper *pointer to newly created stratified raster </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
