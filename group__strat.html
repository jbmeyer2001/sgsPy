<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sgsPy: strat</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sgsPy
   </div>
   <div id="projectbrief">structurally guided sampling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__strat.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">strat <div class="ingroups"><a class="el" href="group__dev.html">Developer Documentation</a> &raquo; <a class="el" href="group__sample.html">sample</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:sgs_3A_3Astrat_3A_3AOptimAllocationDataManager" id="r_sgs_3A_3Astrat_3A_3AOptimAllocationDataManager"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsgs_1_1strat_1_1OptimAllocationDataManager.html">sgs::strat::OptimAllocationDataManager</a></td></tr>
<tr class="memitem:sgs_3A_3Astrat_3A_3AIndexStorageVectors" id="r_sgs_3A_3Astrat_3A_3AIndexStorageVectors"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">sgs::strat::IndexStorageVectors</a></td></tr>
<tr class="memitem:sgs_3A_3Astrat_3A_3AFocalWindow" id="r_sgs_3A_3Astrat_3A_3AFocalWindow"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsgs_1_1strat_1_1FocalWindow.html">sgs::strat::FocalWindow</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga599d1bfb91ba4394b453e04e35ce50a7" id="r_ga599d1bfb91ba4394b453e04e35ce50a7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga599d1bfb91ba4394b453e04e35ce50a7">sgs::strat::calculateAllocation</a> (int64_t numSamples, std::string allocation, std::vector&lt; int64_t &gt; strataCounts, std::vector&lt; double &gt; weights, int64_t numPixels)</td></tr>
<tr class="memitem:ga36120d49fad818c08719bbbea9a60f88" id="r_ga36120d49fad818c08719bbbea9a60f88"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga36120d49fad818c08719bbbea9a60f88 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga36120d49fad818c08719bbbea9a60f88">sgs::strat::processBlocksStratRandom</a> (int numSamples, int numStrata, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;band, <a class="el" href="structsgs_1_1access_1_1Access.html">access::Access</a> &amp;access, <a class="el" href="structsgs_1_1existing_1_1Existing.html">existing::Existing</a> &amp;existing, <a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">IndexStorageVectors</a> &amp;indices, std::vector&lt; std::vector&lt; OGRPoint &gt; &gt; &amp;existingSamples, uint64_t multiplier, xso::xoshiro_4x64_plus &amp;rng, std::string allocation, <a class="el" href="structsgs_1_1strat_1_1OptimAllocationDataManager.html">OptimAllocationDataManager</a> &amp;optim, std::vector&lt; double &gt; weights, int width, int height)</td></tr>
<tr class="memitem:ga403d17022991838519ee8e759ee1eb78" id="r_ga403d17022991838519ee8e759ee1eb78"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga403d17022991838519ee8e759ee1eb78 template"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga403d17022991838519ee8e759ee1eb78">sgs::strat::processBlocksStratQueinnec</a> (int numSamples, int numStrata, <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;band, <a class="el" href="structsgs_1_1access_1_1Access.html">access::Access</a> &amp;access, <a class="el" href="structsgs_1_1existing_1_1Existing.html">existing::Existing</a> &amp;existing, <a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">IndexStorageVectors</a> &amp;indices, <a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">IndexStorageVectors</a> &amp;queinnecIndices, <a class="el" href="structsgs_1_1strat_1_1FocalWindow.html">FocalWindow</a> &amp;fw, std::vector&lt; std::vector&lt; OGRPoint &gt; &gt; &amp;existingSamples, uint64_t multiplier, uint64_t queinnecMultiplier, xso::xoshiro_4x64_plus &amp;rng, std::string allocation, <a class="el" href="structsgs_1_1strat_1_1OptimAllocationDataManager.html">OptimAllocationDataManager</a> &amp;optim, std::vector&lt; double &gt; weights, int width, int height)</td></tr>
<tr class="memitem:gab016c212cf4e17ec0a3ba6bd136cde3c" id="r_gab016c212cf4e17ec0a3ba6bd136cde3c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::vector&lt; double &gt; &gt;, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gab016c212cf4e17ec0a3ba6bd136cde3c">sgs::strat::strat</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, int bandNum, int64_t numSamples, int64_t numStrata, std::string allocation, std::vector&lt; double &gt; weights, <a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_mraster, int mrastBandNum, std::string method, int wrow, int wcol, double mindist, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *p_existing, bool force, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *p_access, std::string layerName, double buffInner, double buffOuter, bool plot, std::string filename, std::string tempFolder)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga599d1bfb91ba4394b453e04e35ce50a7" name="ga599d1bfb91ba4394b453e04e35ce50a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599d1bfb91ba4394b453e04e35ce50a7">&#9670;&#160;</a></span>calculateAllocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; sgs::strat::calculateAllocation </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>strataCounts</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>numPixels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function which calculates the count of values for each strata depending on the allocation method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::string</td><td>allocation method </td></tr>
    <tr><td class="paramname">std::vector&lt;size_t&gt;&amp;</td><td>sizes of each strata </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;</td><td>weights of each strata </td></tr>
    <tr><td class="paramname">size_t</td><td>total number of pixels </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;size_t&gt; counts of each stratum </dd></dl>

</div>
</div>
<a id="ga403d17022991838519ee8e759ee1eb78" name="ga403d17022991838519ee8e759ee1eb78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga403d17022991838519ee8e759ee1eb78">&#9670;&#160;</a></span>processBlocksStratQueinnec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; sgs::strat::processBlocksStratQueinnec </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numStrata</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>band</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1access_1_1Access.html">access::Access</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>access</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1existing_1_1Existing.html">existing::Existing</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">IndexStorageVectors</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">IndexStorageVectors</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>queinnecIndices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1strat_1_1FocalWindow.html">FocalWindow</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>fw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; OGRPoint &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>existingSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>queinnecMultiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xso::xoshiro_4x64_plus &amp;</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1strat_1_1OptimAllocationDataManager.html">OptimAllocationDataManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>optim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function processes the strat raster in blocks using the 'Queinnec' method. In the Queinnec method, pixels which are surrounded by pixels of the same strata are prioritized for sampling over pixels which aren't.</p>
<p>First, the block size is adjusted to be scanlines with a height of either the original y block size, or 128. This is done because the raster needs to be read as scanlines for the <a class="el" href="structsgs_1_1strat_1_1FocalWindow.html">FocalWindow</a> struct to work well and not get any more complicated than it already is. However, we want the raster IO to still be as efficient as possible, so chunks of the raster are still read on block boundaries, just containing a lot more than just 1 block. <br  />
</p>
<p>Next, memory is allocated and structs are created for random value calculation and optim allocation. More memory is allocated than just 1 of the chunks (xBlockSize * yBlockSize), this is because usign the focal window struct method, we may have to read in some of the final few pixels of the previous chunk, to the start of the new chunk.</p>
<p>Next, iterate thorugh the blocks within the raster. For each block:</p><ul>
<li>read block from the strat raster</li>
<li>calculate rand values (both normal and queinnec) for the new block</li>
<li>iterate through the pixels in the block</li>
</ul>
<p>The newBlockStart value is used due to the aforementioned padding which may be placed on the top of the new block. This newBlockStart value is the index of the block which is the start of the new block. This value will be 0 in the case of the first block, but different otherwise.</p>
<p>Rather than using a typical nested for loop, one for the vertical and one for the horizontal, we use one for the vertical and three for the horizontal. This is because there are areas on the left and right of the raster which will never be eligible as queinnec pixels because their focal window includes pixels which go off the edge of the raster. And, critically, trying to calculate whether they are horizontally eligible as a queinnec pixel would result in checking a pixel which either doesn't exist or is on the opposite side of the raster.</p>
<p>For each pixel horizontally not eligible to be a queinnec pixel:</p><ul>
<li>ignore the pixel if it is a nan value</li>
<li>update the optim variances if optim allocation is used</li>
<li>update total sample counts</li>
<li>add index to existing vector if the pixel is part of an existing sample network</li>
<li>if the pixel is both accessible and not already sampled, update the index storage vectors.</li>
</ul>
<p>For pixel which is horizontally eligible to be a queinnec pixel:</p><ul>
<li>do all of the same as those non-eligible pixels in addition to...</li>
<li>set focal window valid vector for the current pixel</li>
<li>set focal window matrix vector for the current pixel by checking horizontally adjacent pixels</li>
<li>check the focal window matrix for the pixel which will have just had all of it's vertical pixels horizontally checked. Calling this check on a pixel which would have a negative y will always result in a false due to the focal window matrix being automatically set to false. If this check succeeds &ndash; check vertical pixels to see if they are the same and if so update the queinnec index storage vectors.</li>
</ul>
<p>Once all blocks have been processed, free any allocated memory and calculate the sample allocation per strata, and return this allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>numSamples </td></tr>
    <tr><td class="paramname">int</td><td>numStreata </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>band </td></tr>
    <tr><td class="paramname">Access&amp;</td><td>access </td></tr>
    <tr><td class="paramname">Existing&amp;</td><td>existing </td></tr>
    <tr><td class="paramname">IndexStorageVectors&amp;</td><td>indices </td></tr>
    <tr><td class="paramname">IndexStorageVectors&amp;</td><td>queinnecIndices </td></tr>
    <tr><td class="paramname">FocalWindow&amp;</td><td>fw </td></tr>
    <tr><td class="paramname">std::vector&lt;std::vector&lt;OGRPoint&gt;&gt;&amp;</td><td>existingSamples </td></tr>
    <tr><td class="paramname">uint64_t</td><td>multiplier </td></tr>
    <tr><td class="paramname">uint64_t</td><td>queinnecMultiplier </td></tr>
    <tr><td class="paramname">xso::xoshiro_4x64_plus&amp;</td><td>rng </td></tr>
    <tr><td class="paramname">std::string</td><td>allocation </td></tr>
    <tr><td class="paramname">OptimAllocatoinDataManager&amp;</td><td>optim </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;</td><td>weights </td></tr>
    <tr><td class="paramname">int</td><td>width </td></tr>
    <tr><td class="paramname">int</td><td>height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int64_t&gt; </dd></dl>

</div>
</div>
<a id="ga36120d49fad818c08719bbbea9a60f88" name="ga36120d49fad818c08719bbbea9a60f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36120d49fad818c08719bbbea9a60f88">&#9670;&#160;</a></span>processBlocksStratRandom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int64_t &gt; sgs::strat::processBlocksStratRandom </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numStrata</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>band</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1access_1_1Access.html">access::Access</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>access</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1existing_1_1Existing.html">existing::Existing</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1strat_1_1IndexStorageVectors.html">IndexStorageVectors</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; OGRPoint &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>existingSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t</td>          <td class="paramname"><span class="paramname"><em>multiplier</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xso::xoshiro_4x64_plus &amp;</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1strat_1_1OptimAllocationDataManager.html">OptimAllocationDataManager</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>optim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function processes the strat raster in blocks using the 'random' method. In the random method, every pixel in a particular strata has the same priority of being added as any other pixel in that strata.</p>
<p>First, memory is allocated and structures are initialized for random value calculation and optim allocation.</p>
<p>Next, iterate through the blocks within the raster. For each block:</p><ul>
<li>read the strat raster (and potentially access &amp; optim rasters) into memory</li>
<li>calculate rand values for the new block</li>
<li>iterate through the pixels in the block</li>
</ul>
<p>For each pixel:</p><ul>
<li>ignore the pixel if it is a nan value</li>
<li>update the optim variances if optim allocation used</li>
<li>update total sample counts</li>
<li>add index to existing vector if the pixel is part of an existing sample network</li>
<li>If the pixel is both accessible and not already sampled, update the index storage vectors</li>
</ul>
<p>Once all blocks have been processed, free any allocated memory and calculate the sample allocation per strata, and return this allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">int</td><td>numSamples </td></tr>
    <tr><td class="paramname">int</td><td>numStrata </td></tr>
    <tr><td class="paramname">RasterBandMetaData&amp;</td><td>band </td></tr>
    <tr><td class="paramname">Access&amp;</td><td>access </td></tr>
    <tr><td class="paramname">Existing&amp;</td><td>existing </td></tr>
    <tr><td class="paramname">IndexStorageVectors&amp;</td><td>indices </td></tr>
    <tr><td class="paramname">std::vector&lt;std::vector&lt;OGRPoint&gt;&gt;&amp;</td><td>existingSamples </td></tr>
    <tr><td class="paramname">uint64_t</td><td>multiplier </td></tr>
    <tr><td class="paramname">xoshiro_4x64_plus&amp;</td><td>rng </td></tr>
    <tr><td class="paramname">std::string</td><td>allocation </td></tr>
    <tr><td class="paramname">OptimAllocationDataManager&amp;</td><td>optim </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;weights</td><td></td></tr>
    <tr><td class="paramname">int</td><td>width </td></tr>
    <tr><td class="paramname">int</td><td>height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int64_t&gt; </dd></dl>

</div>
</div>
<a id="gab016c212cf4e17ec0a3ba6bd136cde3c" name="gab016c212cf4e17ec0a3ba6bd136cde3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab016c212cf4e17ec0a3ba6bd136cde3c">&#9670;&#160;</a></span>strat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::vector&lt; double &gt; &gt;, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *, size_t &gt; sgs::strat::strat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bandNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>numSamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>numStrata</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>allocation</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_mraster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>mrastBandNum</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>wrow</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>wcol</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>mindist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_existing</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>force</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_access</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>buffInner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>buffOuter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>plot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>tempFolder</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function conducts stratified random sampling on the provided stratified raster.</p>
<p>First, metadata is acquired in the strat raster band, which is to be read to determine sample strata and to ensure samples don't occur on nan values.</p>
<p>Next, the output vector dataset is creates as an in-memory dataset. If the user specifies a filename, this in-memory dataset will be written to disk in a different format after all points have been added.</p>
<p>An Access struct is created, which creates a raster dataset containing a rasterized version of access buffers. This raster will be 1 over accessible areas. In the case where there is no access vector given, the structs 'used' member will be false and no processing or rasterization will be done.</p>
<p>An Existing struct is created, which retains information on already existing sample points passed in the form of a vector dataset. The points are iterated through and added to the output dataset. The points are also added to a set, and during iteration the indexes of every pixel will be checked against this set to ensure there are no duplicate pixels. In the case whre there is no existing vector given, the structs 'used' member will be false and no processing will be done.</p>
<p>Next, a rng() function is created usign the xoshiro library, the specific randm number generator is the xoshrio256++ <a href="https://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf">https://vigna.di.unimi.it/ftp/papers/ScrambledLinear.pdf</a> <br  />
</p>
<p>The impetus behind usign the rng() function to determine which pixels should be added DURING iteration, rather than afterwards, is it removes the necessity of storing every available pixel, which quickly becomes extrordinarily inefficient for large rasters. Rather, for pixels which are accessible, not nan, and not already existing, there is a pre-determined percentage chance to be stored which uses this random number generator. An over-estimation for the percentage chance is made, because it is better to have too many than not enough possible options to sample from. This over-estimation might result in the storage of 2x-3x extra pixels rather than the many orders of magnitude extra storage of adding all pixels. The calculation for this percentage is done and explained in detail in the getProbabilityMultiplier() function.</p>
<p>Next, the raster is processed in blocks either using the 'random' or 'Queinnec' methods, and the return of those functions contains the allocation of samples per strata.</p>
<p>Strata are iterated through, with samples being added according to their total allocation. First, existing pixels are added, all of which are added in the case where the force parameter is true. Next, queinnec pixels are added if the queinnec method is used. Finally, remaining random pixels are added.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">int</td><td>bandNum </td></tr>
    <tr><td class="paramname">int64_t</td><td>numSamples </td></tr>
    <tr><td class="paramname">int64_t</td><td>numStrata </td></tr>
    <tr><td class="paramname">std::string</td><td>allocation </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;</td><td>weights </td></tr>
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_mraster </td></tr>
    <tr><td class="paramname">int</td><td>mrasterBandNum </td></tr>
    <tr><td class="paramname">std::string</td><td>method </td></tr>
    <tr><td class="paramname">int</td><td>wrow </td></tr>
    <tr><td class="paramname">int</td><td>wcol </td></tr>
    <tr><td class="paramname">double</td><td>mindist </td></tr>
    <tr><td class="paramname">GDALVectorWrapper</td><td>*p_existing </td></tr>
    <tr><td class="paramname">bool</td><td>force </td></tr>
    <tr><td class="paramname">GDALVectorWrapper</td><td>*p_access </td></tr>
    <tr><td class="paramname">std::string</td><td>layerName </td></tr>
    <tr><td class="paramname">double</td><td>buffInner </td></tr>
    <tr><td class="paramname">double</td><td>buffOuter </td></tr>
    <tr><td class="paramname">bool</td><td>plot </td></tr>
    <tr><td class="paramname">std::string</td><td>filename </td></tr>
    <tr><td class="paramname">std::string</td><td>tempFolder</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt; std::vector&lt;std::vector&lt;double&gt;&gt;, GDALVectorWrapper *, size_t &gt; </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
