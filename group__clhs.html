<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sgsPy: clhs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">sgsPy
   </div>
   <div id="projectbrief">structurally guided sampling</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('group__clhs.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">clhs <div class="ingroups"><a class="el" href="group__dev.html">Developer Documentation</a> &raquo; <a class="el" href="group__sample.html">sample</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:sgs_3A_3Aclhs_3A_3APoint_3C_20T_20_3E" id="r_sgs_3A_3Aclhs_3A_3APoint_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsgs_1_1clhs_1_1Point.html">sgs::clhs::Point&lt; T &gt;</a></td></tr>
<tr class="memitem:sgs_3A_3Aclhs_3A_3ACLHSDataManager_3C_20T_20_3E" id="r_sgs_3A_3Aclhs_3A_3ACLHSDataManager_3C_20T_20_3E"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">sgs::clhs::CLHSDataManager&lt; T &gt;</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0786fa3220971b7f94ad2c7942ffaaeb" id="r_ga0786fa3220971b7f94ad2c7942ffaaeb"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga0786fa3220971b7f94ad2c7942ffaaeb template"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga0786fa3220971b7f94ad2c7942ffaaeb">sgs::clhs::getQuantile</a> (T val, std::vector&lt; T &gt; &amp;quantiles)</td></tr>
<tr class="memitem:ga5578eb2a134133eb8289e36da694f172" id="r_ga5578eb2a134133eb8289e36da694f172"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga5578eb2a134133eb8289e36da694f172 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5578eb2a134133eb8289e36da694f172">sgs::clhs::readRaster</a> (std::vector&lt; <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &gt; &amp;bands, <a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">CLHSDataManager</a>&lt; T &gt; &amp;<a class="el" href="#ga99b0ad3266f6145d1ebef60b799c2c1c">clhs</a>, <a class="el" href="structsgs_1_1access_1_1Access.html">access::Access</a> &amp;access, <a class="el" href="classsgs_1_1helper_1_1RandValController.html">helper::RandValController</a> &amp;rand, GDALDataType type, std::vector&lt; std::vector&lt; T &gt; &gt; &amp;quantiles, size_t size, int width, int height, int count, int nSamp)</td></tr>
<tr class="memitem:ga5a01c2ee66c60968706e8ff52648b28a" id="r_ga5a01c2ee66c60968706e8ff52648b28a"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ga5a01c2ee66c60968706e8ff52648b28a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga5a01c2ee66c60968706e8ff52648b28a">sgs::clhs::selectSamples</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;quantiles, <a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">CLHSDataManager</a>&lt; T &gt; &amp;<a class="el" href="#ga99b0ad3266f6145d1ebef60b799c2c1c">clhs</a>, xso::xoshiro_4x64_plus &amp;rng, int iterations, int nSamp, int nFeat, OGRLayer *p_layer, double *GT, bool plot, std::vector&lt; double &gt; &amp;xCoords, std::vector&lt; double &gt; &amp;yCoords)</td></tr>
<tr class="memitem:ga99b0ad3266f6145d1ebef60b799c2c1c" id="r_ga99b0ad3266f6145d1ebef60b799c2c1c"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; std::vector&lt; double &gt; &gt;, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga99b0ad3266f6145d1ebef60b799c2c1c">sgs::clhs::clhs</a> (<a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *p_raster, int nSamp, int iterations, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *p_access, std::string layerName, double buffInner, double buffOuter, bool plot, std::string tempFolder, std::string filename)</td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="ga99b0ad3266f6145d1ebef60b799c2c1c" name="ga99b0ad3266f6145d1ebef60b799c2c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99b0ad3266f6145d1ebef60b799c2c1c">&#9670;&#160;</a></span>clhs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::vector&lt; double &gt; &gt;, <a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> * &gt; sgs::clhs::clhs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsgs_1_1raster_1_1GDALRasterWrapper.html">raster::GDALRasterWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_raster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nSamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1vector_1_1GDALVectorWrapper.html">vector::GDALVectorWrapper</a> *</td>          <td class="paramname"><span class="paramname"><em>p_access</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>buffInner</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>buffOuter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>plot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>tempFolder</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function conducts Conditioned Latin Hypercube Sampling (CLHS) on a given raster.</p>
<p>First, metadata is acquired for each band within the raster, and an output vector file is created in-memory which is where chosen sample points will be written to.</p>
<p>The <a class="el" href="#ga5578eb2a134133eb8289e36da694f172">readRaster()</a> function is called, which iterates through the raster in blocks and calculates the quantiles for each feature, as well as the correlation matrix, for the entire sampling space. It also selects pixels and adds them to a pool.</p>
<p>The <a class="el" href="#ga5a01c2ee66c60968706e8ff52648b28a">selectSamples()</a> function utilizes a simulated annealing algorithm taking into account the differences in correlation matrix between the sample and the overall sample space, as well as how close to a latin hypercube the sample is. The points which this algorithm choses from are from the pool of pixels added in the <a class="el" href="#ga5578eb2a134133eb8289e36da694f172">readRaster()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">GDALRasterWrapper</td><td>*p_raster </td></tr>
    <tr><td class="paramname">int</td><td>nSamp </td></tr>
    <tr><td class="paramname">int</td><td>iterations </td></tr>
    <tr><td class="paramname">GDALVectorWrapper</td><td>*p_access </td></tr>
    <tr><td class="paramname">std::string</td><td>layerName </td></tr>
    <tr><td class="paramname">double</td><td>buffInner </td></tr>
    <tr><td class="paramname">double</td><td>buffOuter </td></tr>
    <tr><td class="paramname">bool</td><td>plot </td></tr>
    <tr><td class="paramname">std::string</td><td>tempFolder </td></tr>
    <tr><td class="paramname">std::string</td><td>filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::tuple&lt;std::vector&lt;std::vector&lt;double&gt;&gt;, GDALVectorWrapper *&gt; </dd></dl>

</div>
</div>
<a id="ga0786fa3220971b7f94ad2c7942ffaaeb" name="ga0786fa3220971b7f94ad2c7942ffaaeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0786fa3220971b7f94ad2c7942ffaaeb">&#9670;&#160;</a></span>getQuantile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t sgs::clhs::getQuantile </td>
          <td>(</td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is used to get the quantile which a particular value fits into. It requires both that value, and a vector of the quantile values to be passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>val </td></tr>
    <tr><td class="paramname">std::vector&lt;T&gt;&amp;</td><td>quantiles </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t </dd></dl>

</div>
</div>
<a id="ga5578eb2a134133eb8289e36da694f172" name="ga5578eb2a134133eb8289e36da694f172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5578eb2a134133eb8289e36da694f172">&#9670;&#160;</a></span>readRaster()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::clhs::readRaster </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structsgs_1_1helper_1_1RasterBandMetaData.html">helper::RasterBandMetaData</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">CLHSDataManager</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsgs_1_1access_1_1Access.html">access::Access</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>access</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1helper_1_1RandValController.html">helper::RandValController</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rand</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GDALDataType</td>          <td class="paramname"><span class="paramname"><em>type</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nSamp</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is responsible for three different tasks as it reads through the raster. The raster is read in blocks, so as to be as memory efficient as possible and avoid the potential issue of a raster which is too large to fit in memory.</p>
<p>The three tasks are as follows:</p><ul>
<li>calculate the quantile values for every feature, where the number of equally sized quantiles is the sample size.</li>
<li>calculate the correltion matrix of the features in the raster.</li>
<li>Save points, along with their x/y coordinates.</li>
</ul>
<p>QUANTILES: MKL (Math Kernel Library) is used to calculate the quantiles using a quantile streaming algorithm. As the pixels are iterated through, each pixel is a row an each feature is a column &ndash; this is because it is how the correlation matrix calculation expects the values to be, but it also simplifies the removal of nan pixels. However, the quantile calculation is done per-feature, so each feature has it's own vector of values which are copied over from the original matrix while reading. These are in the quantileBuffers vector of vectors.</p>
<p>Additionally, there are seperate MKL functions for single precision vs double precision floating point values. For this reason, the type is passed (in addition to being templated) so that the correct MKL function is called according to the data type of the raster.</p>
<p>Due to the template function also being passed, the pointer type passed to those type-specific MKL functions must be casted to the correct type. This is because, the C++ compiler is not aware that the float template will never be passed along with a type of GDT_Float64, and double will never be passed along with a type of GDT_Float32.</p>
<p>CORRELATION: oneDAL is used to calculate the correlation matrix of the raster features using a streaming algorithm. The features are read such that a pixel corresponds to a row and a feature corresponds to a column in the buffer passed to the quantile streaming algorithm. This is to simplify the removal of nan pixels, and to maximize cache-line efficiency.</p>
<p>POINTS: The most obvious way to calculate clhs would be to read the entire raster into memory, remove the nan pixels, then run the simulated annealing algorithm over the entire raster. Essentially, every pixel in the raster has an equal chance of being selected. This method however falls apart when there are enough pixels so as to be encredibly memory-inefficent, or so many that they can't fit in memory at once. In this case, we cannot store the features of every single pixel.</p>
<p>Instead, as we iterate through the raster we randomly select pixels which will be added to a pool. The pixels within that pool are options for being added to the latin hypercube. The probability of each pixel being added to this pool depends on the total size of the raster (as well as the number of accessible pixels, if the access parameter is given), but every accessible pixel has an equal chance of being included in the pool. The size goal for the pool is 10,000,000 pixels because it is (hopefully) enough to give the simulated annealing algorithm all the options for quantiles it needs, without breaking memory. If the raster has a small enough number of pixels however, they will all be added to the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;RasterBandMetaData&gt;&amp;</td><td>bands </td></tr>
    <tr><td class="paramname"><a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">CLHSDataManager&lt;T&gt;&amp;</a></td><td>clhs </td></tr>
    <tr><td class="paramname">Access&amp;</td><td>access </td></tr>
    <tr><td class="paramname">RandValController&amp;</td><td>rand </td></tr>
    <tr><td class="paramname">GDALDataType</td><td>type </td></tr>
    <tr><td class="paramname">std::vector&lt;std::vector&lt;T&gt;&gt;&amp;</td><td>quantiles </td></tr>
    <tr><td class="paramname">size_t</td><td>size </td></tr>
    <tr><td class="paramname">int</td><td>width </td></tr>
    <tr><td class="paramname">int</td><td>height </td></tr>
    <tr><td class="paramname">int</td><td>count </td></tr>
    <tr><td class="paramname">int</td><td>nSamp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a01c2ee66c60968706e8ff52648b28a" name="ga5a01c2ee66c60968706e8ff52648b28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a01c2ee66c60968706e8ff52648b28a">&#9670;&#160;</a></span>selectSamples()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sgs::clhs::selectSamples </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; T &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quantiles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">CLHSDataManager</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>clhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">xso::xoshiro_4x64_plus &amp;</td>          <td class="paramname"><span class="paramname"><em>rng</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>iterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nSamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nFeat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OGRLayer *</td>          <td class="paramname"><span class="paramname"><em>p_layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>GT</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>plot</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>xCoords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>yCoords</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is responsible for selecting the samples will be in the final sample using the Conditioned Latin Hypercube Sampling (clhs) method. The <a class="el" href="classsgs_1_1clhs_1_1CLHSDataManager.html">CLHSDataManager</a> contains a pool of points which may be selected, as well as objective functions which will calculate how good each sample is depending on the number of samples within each features quantiles, and how closely matching the correlation matrices are between the sample compared to the entire sample space.</p>
<p>The clhs method uses a simulated annealing algorithm, wherein the sample is constanty being updated and tested by replacing one of the samples. The old vs new samples are compared usign the objective functions, and the likelyhood that the sample is added (whether it's an improvement or not) depends both on a random probability, and the tempreature parameter which decreases after every iteration. Essentially, at the start of the algorithm it is far more likely that a sample may be accepted if it makes the objective function worse. The reason why the algorithm doesn't always accept an improvement and reject a decrease is to avoid finding a local maximum (which is not a global maximum). At the start of each iteration, there is also a 50% chance that the sample removed is NOT random, but removed from the quantile which has the most samples (essentially removing the 'worst' pixel).</p>
<p>Once all of the samples are chosen, they are added to the output layer and the function completes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">std::vector&lt;std::vector&lt;T&gt;&gt;&amp;</td><td>quantiles </td></tr>
    <tr><td class="paramname">xso::xoshiro_4x64_plus&amp;</td><td>rng </td></tr>
    <tr><td class="paramname">int</td><td>iterations </td></tr>
    <tr><td class="paramname">int</td><td>nSamp </td></tr>
    <tr><td class="paramname">int</td><td>nFeat </td></tr>
    <tr><td class="paramname">OGRLayer</td><td>*p_layer </td></tr>
    <tr><td class="paramname">double</td><td>*GT </td></tr>
    <tr><td class="paramname">bool</td><td>plot </td></tr>
    <tr><td class="paramname">std::vector&lt;double&gt;&amp;</td><td>xCoords </td></tr>
    <tr><td class="paramname">std::Vector&lt;double&gt;&amp;</td><td>yCoords </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
